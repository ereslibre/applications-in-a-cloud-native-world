# Monolith

Enter the *monolith*. Let's have some fun by reading [one of the
Cambridge's dictionary definitions](https://dictionary.cambridge.org/dictionary/english/service):

> *monolith*: a large block of stone standing by itself that was put up by people in ancient times.

First things first: a monolith does not intrinsically signal a bad
design. As we will learn throughout the book, a monolith could be a
perfectly sane solution for many projects and teams. Moreover, it can
even be the best solution given a certain set of constraints.

Let's get to a more focused definition of a *monolithic application*
as defined by the [Wikipedia](https://en.wikipedia.org/wiki/Monolithic_application):

> a *monolithic application* describes a single-tiered software
> application in which the user interface and data access code are
> combined into a single program from a single platform.

However, when transposing this definition to client-side
architectures, we could argue that the fact that the backend is a
single-tiered application is in itself a *monolith*, even if the user
interface is not strictly provided by the backend.
